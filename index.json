[{"uri":"https://npmh1909.github.io/foodapp-high-availability/","title":"Build FoodApp System with High Availability Architecture","tags":[],"description":"","content":"Build FoodApp System with High Availability Architecture Overview In this lab, we will build the FoodApp system deployed on AWS using a multi-tier, highly available, auto scalable architecture.\nContent Introduction Prepare AWS Infrastructure Store Images with Amazon S3 Configure Email Sending with Amazon SES Deploy Amazon DocumentDB Deploy Backend Deploying Frontend and Configuring CloudFront Logging Cleanup Resources "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.1-connectservice/","title":"Configure connection to AWS Services","tags":[],"description":"","content":"In this step, we will configure the connection between the Node.js application and AWS services including:\nAmazon S3: used for image storage Amazon SES: used to send automated emails Configure Node.js connection with Amazon S3 Install AWS SDK npm install aws-sdk Configure AWS SDK in Node.js Create a file named s3.config.js in your config directory to establish the connection with S3.\nimport AWS from \u0026#39;aws-sdk\u0026#39;; import dotenv from \u0026#39;dotenv\u0026#39;; const s3 = new AWS.S3({ accessKeyId: process.env.ACCESSKEYID, secretAccessKey: process.env.SECRETACCESSKEY, region: process.env.REGION, }); export default s3; Create middleware to handle image uploads to S3 We will use multer and multer-s3 to handle file uploads to S3. Install the required packages:\nnpm install multer multer-s3 Create a middleware file uploadFiles.js to handle uploads:\nimport multer from \u0026#39;multer\u0026#39;; import multerS3 from \u0026#39;multer-s3\u0026#39;; import s3 from \u0026#39;../configs/s3.config.js\u0026#39;; const upload = multer({ storage: multerS3({ s3: s3, bucket: \u0026#39;orderingfood-images\u0026#39;, contentType: multerS3.AUTO_CONTENT_TYPE, metadata: (req, file, cb) =\u0026gt; { cb(null, { fieldName: file.fieldname }); }, key: (req, file, cb) =\u0026gt; { const fileName = `${Date.now()}-${file.originalname}`; cb(null, fileName); // Tạo tên file duy nhất }, }), }); const uploadFiles = (req, res, next) =\u0026gt; { upload.single(\u0026#39;image\u0026#39;)(req, res, (err) =\u0026gt; { if (err) { return res.status(400).json({ success: false, message: \u0026#39;Lỗi trong quá trình upload hình ảnh.\u0026#39;, error: err.message, }); } next(); }); }; export default uploadFiles; orderingfood-images is the name of the S3 bucket.\nConfigure Node.js connection with Amazon SES To use SES for sending emails, we will also use the AWS SDK for JavaScript.\nInstall AWS SDK and Nodemailer npm install aws-sdk nodemailer Configure SES and Nodemailer Create a file mail.config.js to set up SES and Nodemailer:\nimport dotenv from \u0026#39;dotenv\u0026#39;; import AWS from \u0026#39;aws-sdk\u0026#39;; import nodemailer from \u0026#39;nodemailer\u0026#39;; dotenv.config(); AWS.config.update({ accessKeyId: process.env.ACCESS_KEY_ID, secretAccessKey: process.env.SECRET_ACCESS_KEY, region: process.env.REGION, }); const ses = new AWS.SES({ apiVersion: \u0026#39;2010-12-01\u0026#39; }); export const transporter = nodemailer.createTransport({ SES: { ses, aws: AWS }, }); export const MAIL_CONFIG = { FROM_EMAIL: process.env.SES_FROM_EMAIL, }; Send email using Nodemailer and SES Use the transporter from Nodemailer to send email via SES. The following code demonstrates how to send an email:\nimport { transporter, MAIL_CONFIG } from \u0026#39;../configs/mail.config.js\u0026#39;; const sendMail = async ({ to, subject, html }) =\u0026gt; { const mailData = { from: MAIL_CONFIG.FROM_EMAIL, to, subject, html, }; try { const info = await transporter.sendMail(mailData); console.log(\u0026#39;Email sent:\u0026#39;, info.messageId); return { from: info.envelope.from, to: info.envelope.to, subject, html, }; } catch (error) { console.error(\u0026#39;Error sending email:\u0026#39;, error); throw error; } }; "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.1-vpcandsubnets/","title":"Create VPC and Subnet","tags":[],"description":"","content":"Creating a VPC and Subnets is the foundational step in setting up the network architecture for the FoodApp system. The VPC allows you to isolate and control resources within a private network space, while Subnets enable the separation of infrastructure into Public and Private zones. This ensures security, scalability, and logical organization for components like EC2, ALB, DocumentDB, etc.\nIn this section, we will create:\n1 VPC with CIDR block 10.0.0.0/16 2 Public Subnets (for ALB, public EC2) 2 Private Subnets (for database and secure backend) Create VPC Launch VPC creation Open the VPC Dashboard on AWS Console. Click Create VPC. Configure the VPC Resource to create: Select VPC only Name tag: Enter vpc-foodapp IPv4 CIDR block: 10.0.0.0/16 Click Create VPC to finish. Verify the result Once created, a success message for the new VPC will appear. Create Subnets Launch Subnet creation Open the VPC Dashboard, then go to the Subnets tab. Click Create subnet Configure Subnet Public Subnet 1 VPC ID: Select vpc-foodapp Subnet name: subnet-public-1 Availability Zone: ap-southeast-1a IPv4 subnet CIDR block: 10.0.1.0/24 Click Create subnet Verify the result A success message will confirm the creation. Repeat the process for the following subnets:\nPublic Subnet 2 VPC ID: Select vpc-foodapp Subnet name: subnet-public-2 Availability Zone: ap-southeast-1b IPv4 subnet CIDR block: 10.0.2.0/24 Private Subnet 1 VPC ID: Select vpc-foodapp Subnet name: subnet-private-1 Availability Zone: ap-southeast-1a IPv4 subnet CIDR block: 10.0.11.0/24 Private Subnet 2 VPC ID: Select vpc-foodapp Subnet name: subnet-private-2 Availability Zone: ap-southeast-1b IPv4 subnet CIDR block: 10.0.12.0/24 Public Subnets are associated with a Route Table connected to an Internet Gateway, whereas Private Subnets have no route to the Internet, making them ideal for secure backend or database workloads.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/7-frontend/7.1-s3static/","title":"Deploy frontend to Amazon S3","tags":[],"description":"","content":"Amazon S3 allows you to deploy static frontend applications (HTML, CSS, JS) in a simple, fast, and efficient way. In this section, we will:\nCreate an S3 bucket to store frontend source code Enable Static Website Hosting Grant public access so users can view the site Access the website via the S3 endpoint After completing this step, you’ll have a publicly accessible frontend website that can be tested and connected to the backend running on the Load Balancer.\nCreate bucket Update environment variables Update the backend API to use the HTTPS domain: https://food.npmhfoodapp.online/ Build the frontend using the command npm run build The dist folder will be generated Create the bucket Go to S3 Click Create bucket Configure the bucket Bucket type: Select General purpose Bucket name: foodapp-frontend-v1 Uncheck: Block all public access Check: I acknowledge that the current settings might result in this bucket and the objects within becoming public Click Create bucket Upload source code to the bucket Select the newly created bucket In the Objects tab, click Upload Select all files from the generated dist folder Click Upload Enable Static Website Hosting Inside the bucket, go to the Properties tab In the Static website hosting section, click Edit Select Enable Index document: index.html Error document: index.html Click Save changes If you do not grant public access as shown above, users will receive an Access Denied error when visiting the site. Make sure Block all public access is unchecked and the bucket policy is correctly applied.\nSet access permissions Go to the Permissions tab Click Edit Add the following code to the bucket policy: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadForWebsite\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::foodapp-frontend-v1/*\u0026#34; } ] } Click Save changes Verify the result Go to the Properties tab and copy the Bucket website endpoint Visit the DNS endpoint:\nhttp://foodapp-frontend-v1.s3-website-ap-southeast-1.amazonaws.com\nto verify whether the website has been successfully deployed to S3. "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/1-introduction/","title":"Introduction","tags":[],"description":"","content":"This document provides step-by-step guidance to deploy the FoodApp – Online Food Ordering Web App on AWS Cloud using a Highly Available and Auto Scaling architecture. The goal is to build a system that:\nCan automatically scale when traffic increases Is always available (high availability) with minimal downtime Monitors and logs real-time access Optimizes cost by using pay-as-you-go services Deployment Objectives Frontend served from Amazon S3 and CloudFront for performance optimization Node.js backend deployed on EC2 with Auto Scaling Group for elasticity Data stored in Amazon DocumentDB (MongoDB compatible) Image files stored in Amazon S3 Order confirmations and OTPs sent via Amazon SES Monitor frontend access logs using CloudFront Real-time Logging with Kinesis Data Stream Overall Architecture Includes: Frontend: S3 Static Website Hosting + CloudFront CDN Backend (Node.js): EC2 + PM2, auto-scaled via Auto Scaling Group Database: Amazon DocumentDB Image Storage: Amazon S3 Email Service: Amazon SES Log \u0026amp; Monitoring: CloudFront Real-time Logging Kinesis Data Stream CloudWatch (for backend) AWS Services Used Networking:\nAmazon VPC, Subnet, Route Table Internet Gateway, NAT Gateway Security Groups Compute:\nAmazon EC2, Launch Template Auto Scaling Group Storage \u0026amp; CDN:\nAmazon S3 Amazon CloudFront Database:\nAmazon DocumentDB (MongoDB compatible) Messaging \u0026amp; Logging:\nAmazon SES Amazon Kinesis Data Stream CloudFront Real-time Logging CloudWatch Logs IAM \u0026amp; Security:\nIAM Role, IAM Policies Security Groups Sample Source Code You can refer to the following sample repositories:\nBackend (Node.js): OrderingFood_Server Frontend (ReactJS): OrderingFood-Client This guide is structured into practical deployment steps, from infrastructure setup, VPC creation, to application deployment, real-time log configuration, and system optimization.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/5-documentdb/5.1-subnetgroup/","title":"Tạo Subnet Group","tags":[],"description":"","content":"Before creating a DocumentDB Cluster, we need to define a Subnet Group – this is a set of subnets within a VPC where DocumentDB instances can be deployed.\nUsing a Subnet Group allows DocumentDB to:\nAutomatically distribute nodes across different Availability Zones (HA – High Availability) Restrict deployments to secure subnets (Private Subnets), preventing direct access from the Internet In the FoodApp system, we will create a Subnet Group consisting of subnet-private-1 and subnet-private-2 to ensure that DocumentDB is deployed within a private and secure network zone.\nCreate Subnet Group Initialize Subnet Group Go to Amazon DocumentDB Select the Subnet groups tab Click Create Configure Subnet Group and finish Name: docdb-subnet-group Description: DocumentDB subnet group for FoodApp VPC: vpc-foodapp Availability zones \u0026amp; subnets: subnet-private-1 (AZ: ap-southeast-1a) subnet-private-2 (AZ: ap-southeast-1b) Click Create to finish You must select at least 2 subnets in different Availability Zones for DocumentDB to support High Availability. If you select only one AZ, cluster creation will fail.\nSubnets used for DocumentDB must be Private Subnets and have a correct Route Table configuration (i.e., no route through an Internet Gateway).\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/7-frontend/7.2-cloudfront/","title":"Create CloudFront Distribution","tags":[],"description":"","content":"Create a CloudFront Distribution to deliver your frontend’s static content quickly and securely via AWS’s global CDN network.\nCloudFront helps reduce page load latency, protect your application with HTTPS, and allows seamless integration with S3 for more efficient and flexible frontend deployment.\nTạo CloudFront Distribution Initialize CloudFront Distribution Go to the CloudFront service Select the Distributions tab Click Create distribution Configure the distribution Distribution name: orderingfood-static-frontend Select: Single website or app Click Next Origin type: Amazon S3 S3 origin: foodapp-frontend-v1.s3.ap-southeast-1.amazonaws.com Tick Allow private S3 bucket access to CloudFront - Recommended Click Next Select Do not enable security protections Click Next Review configuration information Click Create distribution Set Default root object Go to the General tab of the newly created distribution Click Edit In the Default root object field, enter: index.html Click Save changes Create Origin Go to the Origins tab Click Create origin In Origin domain, choose:\nfoodapp-frontend-v1.s3-website-ap-southeast-1.amazonaws.com Click Create origin Update Behavior Go to the Behaviors tab of the distribution Select the behavior and click Edit In the Origin section, re-select:\nfoodapp-frontend-v1.s3-website-ap-southeast-1.amazonaws.com Click Save changes If you don’t select the correct origin in s3-website format, your site will return an AccessDenied error because S3 by default does not support static website hosting via the API interface.\nVerify CloudFront operation Go to the General tab of the distribution Copy the Domain name Open the domain in a browser:\nhttps://d1d8ru89vhbyvx.cloudfront.net/ "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.2-gateway/","title":"Create Internet Gateway, Elastic IP, NAT Gateway","tags":[],"description":"","content":"To ensure network connectivity for resources within the VPC, we need to configure core components such as the Internet Gateway and NAT Gateway.\nInternet Gateway (IGW) allows resources in Public Subnets (like ALB or public EC2) to access the Internet and receive inbound connections. NAT Gateway, combined with an Elastic IP, allows resources in Private Subnets (like backend EC2 or DocumentDB) to send outbound requests to the Internet (e.g., install packages, update systems) while remaining private (no inbound access from the Internet). EC2 instances in Private Subnets cannot connect to the Internet without a NAT Gateway. This is essential for installing packages, downloading updates, etc.\nCreate Internet Gateway Go to the Internet gateways tab Click Create Internet Gateway Configure Internet Gateway Name tag: igw-foodapp Click Create internet gateway Attach the IGW to the VPC Select igw-foodapp Click Actions → Attach to VPC Available VPCs: Select vpc-foodapp Click Attach internet gateway An IGW only works when it is attached to a specific VPC. Each IGW can be attached to only one VPC at a time.\nCreate Allocate Elastic IP (EIP) Go to the Elastic IPs tab Click Allocate Elastic IP address Configure the Elastic IP Network border group: ap-southeast-1 Add Tag: Key: Name Value: eip-nat-gateway Click Allocate Verify the result The system will show a success message An Elastic IP is a static IPv4 address provided by AWS, commonly used for NAT Gateway or EC2. Tagging helps in better resource management.\nCreate NAT Gateway Go to the NAT gateways tab in the left menu Click Create NAT gateway Configure NAT Gateway Name: natgw-foodapp Subnet: subnet-public-1 Elastic IP allocation ID: eip-nat-gateway Click Create NAT gateway Verify the result The system will show a success message NAT Gateways must be created in a Public Subnet. If you select a Private Subnet, it will not work.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.2-configurepm2/","title":"PM2 Setup","tags":[],"description":"","content":"After successfully creating and connecting to the EC2 instance, the next step is to deploy the backend source code and use PM2 to manage the Node.js process.\nPM2 is a process manager for Node.js applications that helps:\nRun the application in the background Automatically restart if the EC2 instance reboots or the backend crashes Easily manage multiple applications In this section, we will:\nClone the source code from GitHub into the EC2 instance Install dependencies and create the .env file with environment variables Run the app manually using node server.js to verify it Install and configure PM2 so the app auto-starts on EC2 boot Setup PM2 Connect to the EC2 instance Go to EC2, select Instances Choose the instance ec2-backend-foodapp Click Connect Use Session Manager Select the Session Manager tab Click Connect Install Node.js environment:\nRun the following commands one by one: sudo apt update sudo apt install -y curl curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - sudo apt install -y nodejs Install backend source code and dependencies node -v cd /home/ssm-user git clone https://github.com/NPMH1909/OrderingFood_Server.git foodapp-backend cd foodapp-backend/ npm install Create .env file to configure environment variables nano .env Run the Node.js server manually to test node server.js Install PM2 to manage backend process npm install -g pm2 pm2 start server.js pm2 save pm2 startup "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/","title":"Preparing AWS Infrastructure","tags":[],"description":"","content":"Before deploying the backend and frontend components of the FoodApp system, we need to set up a secure and standardized network infrastructure on AWS. This chapter provides step-by-step instructions to configure the essential network components to ensure the system is scalable, secure, and stable.\nThe components we will configure include:\nVPC and Subnets: Create an isolated network environment by splitting Public and Private subnets across Availability Zones (AZs). Internet Gateway and NAT Gateway: Enable internet access for resources in both Public and Private subnets. Route Tables: Define routing paths for network traffic to the appropriate gateways. Security Groups: Configure instance-level firewalls to restrict access to services such as EC2, ALB, DocumentDB, etc. IAM Role: Grant EC2 permission to access AWS services such as S3, SES, CloudWatch, and DocumentDB. EC2 Instance: Launch the backend server to handle APIs and communicate with other AWS services. Once you complete this chapter, you’ll have a foundational network infrastructure ready to support the full system deployment.\nCreate VPC and Subnets Create Internet Gateway, Elastic IP, NAT Gateway Create Route Tables Create Security Groups Create EC2 IAM Role Launch EC2 Instance "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/5-documentdb/5.2-documentdb/","title":"Tạo Cluster","tags":[],"description":"","content":"After creating the Subnet Group and configuring the networking setup, the next step is to initialize a DocumentDB Cluster – this will serve as the main data store for the FoodApp system.\nAmazon DocumentDB is a MongoDB-compatible NoSQL database service optimized for high performance, scalability, and durability on AWS.\nIn this section, we will:\nCreate a DocumentDB Cluster named docdb-foodapp with 1 primary instance and 1 replica to ensure high availability Connect the cluster to the backend EC2 instance (created previously) Configure Subnet Group, Security Group, and login credentials (username/password) Ensure data is deployed in Private Subnets and accessible only from the EC2 backend This cluster will handle all backend CRUD operations related to users, orders, food items, etc.\nCreate Cluster Initialize the Cluster Go to Amazon DocumentDB Select the Clusters tab Click Create Basic Cluster Configuration Cluster type: Instance-based cluster Cluster identifier: docdb-foodapp Engine version: 5.0.0 Number of regular replica instances: 1 Instance class: db.t3.medium Adding one replica increases high availability. If the primary node fails, the system can automatically fail over to the replica.\nConnection Settings Cluster storage configuration: Amazon DocumentDB Standard Connectivity: Connect to an EC2 compute resource EC2 instance: ec2-backend-foodapp Authentication \u0026amp; Networking Authentication:\nUsername: Npmh Method: Self managed Password: ****** Network settings:\nVPC: vpc-foodapp Subnet group: docdb-subnet-group VPC security groups: SG-DOCDB DocumentDB should only be deployed in a Private Subnet to avoid direct internet access and enhance security.\nCreate the Cluster Click Create cluster Add a Replica Instance Go to the Instances tab and click Add instance Configuration: Instance identifier: docdb-foodapp2 Instance class: db.t3.medium Click Create "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.3-routetables/","title":"Create Route Tables","tags":[],"description":"","content":"Route Tables determine how network traffic is directed within the VPC. Each subnet must be associated with a Route Table to know where to send traffic.\nIn the FoodApp architecture, we need to create two types of route tables:\nPublic Subnet Route Table: allows public subnets to access the Internet directly via an Internet Gateway. Private Subnet Route Table: allows private subnets to send requests to the Internet via a NAT Gateway while maintaining security. This section will guide you through creating and configuring both route tables, and associating them with the appropriate subnets.\nPublic Subnet Route Table Create a route table In the Route tables tab on the left menu Click Create route table Configure the route table Name: rtb-public-foodapp VPC: vpc-foodapp Click Create route table Add route Go to the Routes tab and click Edit routes Click Add route Destination: 0.0.0.0/0 Target: Internet Gateway – igw-foodapp Click Save changes Associate with Subnet Go to Subnet associations tab Click Edit subnet associations Select: subnet-public-1 subnet-public-2 Click Save associations Private Subnet Route Table Create a route table Go to the Route tables tab in the left menu Click Create route table Configure the route table Name: rtb-private-foodapp VPC: vpc-foodapp Click Create route table Add route Go to the Routes tab Click Edit routes Click Add route Destination: 0.0.0.0/0 Target: NAT Gateway – natgw-foodapp Click Save changes Associate with Subnet Go to Subnet associations tab Click Edit subnet associations Select: subnet-private-1 subnet-private-2 Click Save associations Separating subnets into public and private improves scalability and enhances security, especially when implementing auto scaling or multi-tier architectures.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.3-targetgroup/","title":"Create Target Group","tags":[],"description":"","content":"A Target Group is a collection of backend instances (e.g., EC2 instances) that the Load Balancer will forward requests to. This is a critical intermediary step that allows the Load Balancer to know where to route the incoming traffic.\nIn the FoodApp system, we use the Target Group to:\nLink the Application Load Balancer (ALB) with the backend EC2 instances Configure the communication port (5000) for the Node.js backend Set up a Health Check so that ALB can automatically verify backend health and only route traffic to healthy instances Properly configuring the Target Group ensures a stable system, automatically removes non-responsive instances, and lays the foundation for implementing an Auto Scaling Group in the next step.\nCreate Target Group Initialize Target Group Open the EC2 service in the AWS Console Select the Target Groups section Click Create target group Configure Target Group type Target type: select Instances Name: tg-backend Protocol: HTTP, Port: 5000 VPC: select vpc-foodapp Configure Health Check Protocol: HTTP Path: /menu/getall Port: traffic port Success code: 200-299 Click Next to continue Complete Target Group creation In the Register targets step, select the backend EC2 instance to add Click Include as pending below to add it Click Create target group to finish Verify result Go back to the Target Groups tab, select tg-backend In the Targets tab, the instance will initially show as Unused The Target Group will only begin performing Health Checks after it is attached to a Load Balancer Listener. The Healthy status will appear after the ALB successfully sends a request to the /menu/getall path and receives an HTTP response code in the 200-299 range.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/7-frontend/7.3-log/","title":"Enable CloudFront Logging","tags":[],"description":"","content":"To monitor user access activity to the frontend through CloudFront, we will configure logging using two mechanisms:\nStandard Logging: periodically sends logs to Amazon S3 Real-time Logging: sends real-time logs to Kinesis Data Stream for immediate processing and analysis Before setting up Standard Logging, you need to create an S3 bucket named foodapp-cloudfront-logs for CloudFront to write logs to.\nThe creation process is similar to the orderingfood-images bucket in Image Storage with S3.\nThis bucket will store .gz files containing access information, used for later analysis.\nCreate Kinesis Data Stream Initialize the Data Stream Access the Kinesis service from AWS Console Click Create data stream Configure the Data Stream Name: cloudfront-realtime-logs-stream Complete creation of the Data Stream Click Create data stream The Kinesis Data Stream must be created in the same Region as CloudFront (e.g., ap-southeast-1) and needs write permission (PutRecord) from CloudFront. If created using the Console, this permission is granted automatically.\nConfigure Logging for CloudFront Initialize Real-time Log Configuration Go to the CloudFront service Select the Logs tab Go to Real-time log configurations Click Create configuration Configure the log and complete setup Name: realtimeLogFrontend Sampling rate: 100 (log 100% of requests) Select the following fields from the list: timestamp c-ip cs-method cs-uri-stem sc-status cs(User-Agent) cs(Referer) time-to-first-byte x-edge-result-type Endpoint: select cloudfront-realtime-logs-stream Click Create configuration Sampling rate = 100 means logging every request. If your website has high traffic, consider reducing it to 50 or 10 to save cost.\nConfigure Standard Log Go to your Distribution Select the Logging tab Under Standard log destinations, click Create a log delivery Deliver to: choose Amazon S3 Destination S3 bucket: arn:aws:s3:::foodapp-cloudfront-logs Click Submit The S3 bucket (foodapp-cloudfront-logs) must allow write access from CloudFront. Logs are stored in .gz format, so you need to decompress them to read.\nAttach Real-time Log Configuration Under Attached real-time logs, click Edit Enable the Enable option Log configuration: choose realtimeLogFrontend Click Save changes You can enable/disable Real-time or Standard Logging at any time without affecting the operation of the CloudFront Distribution.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/3-imagestorage/","title":"Store Images with Amazon S3","tags":[],"description":"","content":"In the FoodApp system, users can upload images of dishes, invoices, or avatars. To store and manage these image files in a durable and accessible way for the frontend, we use Amazon S3.\nAmazon S3 (Simple Storage Service) is a highly durable, low-cost object storage service that integrates easily with web applications. In this section, we will create a bucket named orderingfood-images to:\nStore images uploaded from the frontend/backend Allow public access to images via URL (since the frontend needs to display them) Configure appropriate access permissions using a Bucket Policy This bucket will be used by the backend to upload images via SDK, and the frontend will load images using their URLs.\nCreate an S3 Bucket Initialize the bucket Go to Amazon S3, click Create bucket Bucket type: General purpose Bucket name: orderingfood-images Configure Public Access Uncheck Block all public access Check I acknowledge that the current settings might result\u0026hellip; Create the bucket Click Create bucket Set the Bucket Policy Go to the Permissions tab, under Bucket Policy, click Edit Paste the following JSON and click Save changes: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadForObjects\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::orderingfood-images/*\u0026#34; } ] } Granting public read access is necessary for the frontend to display images, but you should only apply this policy to buckets containing static, non-sensitive content.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/4-emailsending/","title":"Configure Email Sending with Amazon SES","tags":[],"description":"","content":"Amazon SES (Simple Email Service) is a flexible, secure, and scalable email sending service widely used in modern web systems. In the FoodApp project, Amazon SES will be used to send important emails such as:\nOrder confirmation E-invoices OTP codes and system notifications Before the application can send emails, we need to verify the sender email address in SES to ensure safety and credibility. This section will guide you through creating an email identity, verifying it, and preparing to integrate SES into the backend.\nSet Up Amazon SES Identity Create an Identity Go to the Amazon SES service in the AWS Console In the Identities tab, click Create Identity Configure Identity Identity type: Email address Enter your email address Click Create identity Verify the Email Address Check your inbox and click the verification link sent by AWS Once verified successfully, the Identity status will change to Verified Initially, SES operates in Sandbox Mode, which means you can only send emails to verified addresses. To send emails to real customers, you must submit a request to move to Production mode.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.4-alb/","title":"Create Application Load Balancer","tags":[],"description":"","content":"Application Load Balancer (ALB) is responsible for distributing HTTP/HTTPS traffic from users to backend EC2 instances, ensuring the system is stable, scalable, and capable of automatically removing unresponsive instances.\nIn the FoodApp system, ALB helps:\nReceive requests from the Internet via port 80 (HTTP) Forward requests to EC2 instances in the Target Group tg-backend Use Health Checks to route traffic only to \u0026ldquo;healthy\u0026rdquo; backends Act as the single access point for users, allowing backend instances to be deployed in private subnets This section will guide you through creating an Application Load Balancer alb-foodapp, associated with VPC vpc-foodapp, operating across 2 Public Subnets, using Security Group SG-ALB, and linking to the pre-created Target Group.\nCreate Certificate Request a certificate Open the AWS Console and search for Certificate Manager In the List certificates tab, click Request to create a new certificate Enter domain name information In Fully qualified domain name, enter:\nfood.npmhfoodapp.online Keep the default options: Allow export: select Disable export Validation method: DNS validation – recommended Key algorithm: RSA 2048 Click Request to proceed Get DNS validation record The status will be Pending validation Copy the following values: CNAME name CNAME value Add DNS record at domain management page (TenTen.vn) Visit: https://domain.tenten.vn Add a CNAME record: Type: CNAME Name: paste CNAME name Value: paste CNAME value Click Save to complete Wait for successful validation Return to the ACM interface The status will change from Pending validation to Issued Create Load Balancer Initialize Load Balancer Go to the EC2 service In the left menu, select Load Balancers Click Create load balancer Under Load Balancer type, choose Application Load Balancer (ALB) and click Create Basic configuration Name: alb-foodapp Scheme: Internet-facing IP address type: IPv4 Network mapping Select VPC: vpc-foodapp Choose 2 public subnets in 2 different Availability Zones: subnet-public-1 (10.0.1.0/24) subnet-public-2 (10.0.2.0/24) Select Security Group: SG-ALB (allow port 443) Configure HTTPS Listener Protocol: HTTPS Port: 443 Default action: forward to Target Group tg-backend (port 5000) Choose SSL certificate: Certificate source: From ACM Certificate: food.npmhfoodapp.online Security policy: ELBSecurityPolicy-TLS13-1-2-Res-2021-06 (recommended) Review and create Load Balancer Review all configurations on the Review page Click Create load balancer Record Load Balancer DNS name After creation is successful, record the DNS value, for example:\nalb-foodapp-465071925.ap-southeast-1.elb.amazonaws.com Update DNS record at TenTen.vn Visit the domain management page: https://domain.tenten.vn Add a CNAME record: Name: food Type: CNAME Value: alb-foodapp-465071925.ap-southeast-1.elb.amazonaws.com Click Save DNS updates may take a few minutes to several hours to propagate globally.\nVisit the website using the configured domain: Address: https://food.npmhfoodapp.online The browser will connect through ALB using HTTPS and forwa "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.4-securitygroups/","title":"Create Security Groups","tags":[],"description":"","content":"Security Groups (SGs) are virtual firewalls operating at the instance level in Amazon VPC, used to control inbound and outbound traffic for resources such as ALB, EC2, and DocumentDB. Proper configuration of SGs is crucial to ensure security, connectivity, and separation of responsibilities between components.\nIn the FoodApp system, we will create 3 Security Groups:\nSG-ALB: Allows HTTP/HTTPS access from the Internet to the Application Load Balancer. SG-EC2: Allows ALB to send requests to the EC2 backend on port 5000. SG-DOCDB: Allows the EC2 backend to access DocumentDB (port 27017). Correct SG configuration ensures that only authorized components can communicate with each other, while blocking unwanted external access.\nCreate Security Group for ALB Initialize Security Group Go to the Security Groups tab Click Create security group Configure Security Group Security group name: SG-ALB Description: ALB security group VPC: vpc-foodapp Inbound rules: Click Add rule Type: HTTP (port 80)\nSource: Anywhere Type: HTTPS (port 443)\nSource: Anywhere Complete security group creation Click Create security group Verify result The system displays a success message Create Security Group for EC2 Initialize Security Group Go to the Security Groups tab Click Create security group Configure Security Group Security group name: SG-EC2 Description: EC2 security group VPC: vpc-foodapp Inbound rules: Click Add rule Type: Custom TCP\nPort: 5000\nSource: Custom – SG-ALB Only allow ALB to access the backend via SG, do not open port 5000 from the Internet to avoid exposing the direct endpoint.\nComplete security group creation Click Create security group Verify result The system displays a success message Create Security Group for DocumentDB Initialize Security Group Go to the Security Groups tab Click Create security group Configure Security Group Security group name: SG-DOCDB Description: DOCDB security group VPC: vpc-foodapp Inbound rules: Click Add rule Type: Custom TCP\nPort: 27017\nSource: Custom – SG-EC2 Only the EC2 backend should access DocumentDB. Ensure the database is in the private subnet and protected from external attacks.\nComplete security group creation Click Create security group Verify result The system displays a success message List of successfully created Security Groups:\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.5-createami/","title":"Create Amazon Machine Image","tags":[],"description":"","content":"After fully installing and configuring the backend on EC2 (including source code, .env file, PM2, etc.), the next step is to create a complete backup of the current system in the form of an Amazon Machine Image (AMI).\nAn AMI contains the full operating system, backend application, and current configurations of the EC2 instance. Creating an AMI allows you to:\nDeploy multiple identical backend EC2s in an Auto Scaling Group (ASG) Ensure all backend instances have the same configuration Reduce the time required for manual backend setup during system scaling In this section, we will create the AMI ami-backend-foodapp from the instance ec2-backend-foodapp to prepare for the next steps: creating a Launch Template and Auto Scaling Group.\nCreate AMIs Initialize AMI creation Go to the AWS EC2 Console, select the Instances tab from the left menu Select the running instance named ec2-backend-foodapp Click the Actions button, choose Image and templates, then select Create image Enter details and create AMI On the Create image screen, set the image name to ami-backend-foodapp Click Create image Check AMI creation progress After creation, the AMI will appear under the AMIs tab. Its initial status will be \u0026ldquo;Pending\u0026rdquo;, and after a few minutes it will change to \u0026ldquo;Available\u0026rdquo; "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/5-documentdb/","title":"Deploy Amazon DocumentDB","tags":[],"description":"","content":"Amazon DocumentDB is a NoSQL database service compatible with MongoDB, designed to run on AWS with high scalability, high availability, and simplified management. In the FoodApp system, DocumentDB serves as the primary data store, responsible for storing:\nUser information Dishes and orders Reviews, feedback, notifications, and more Using DocumentDB allows the backend to work easily with document-based (JSON) data, which is ideal for applications with flexible schemas and rapid development cycles.\nIn this chapter, we will deploy DocumentDB with the following steps:\nCreate a Subnet Group to specify where the cluster will be deployed (within Private Subnets) Create the DocumentDB Cluster and associate it with the appropriate VPC, Security Group, Subnet Group, and the EC2 backend The cluster will be deployed within a private network zone, and only the EC2 backend (via Security Group access) will be allowed to connect to it. This ensures full data security and network isolation.\nCreate Subnet Group Create DocumentDB Cluster "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.5-iamrole/","title":"Tạo IAM Role EC2","tags":[],"description":"","content":"IAM Role is a secure and flexible way to grant permissions to AWS services such as EC2 without using Access Key/Secret Key. Assigning an IAM Role to EC2 allows the backend to:\nAccess Amazon DocumentDB to read/write data Send logs to CloudWatch Send emails via Amazon SES Communicate with SSM (AWS Systems Manager) for easier server management via AWS Console In this section, we will:\nCreate a Custom Policy to allow EC2 to query necessary information from DocumentDB and other services Attach this policy along with other required ones to an IAM Role for EC2 Use this IAM Role when launching the backend EC2 instance later Create Policies Create a new policy Go to IAM Select the Policies tab Click Create policy Configure access rights for the policy Go to the JSON tab Paste the following configuration: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;DocumentDBAccess\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;rds:DescribeDBClusters\u0026#34;, \u0026#34;rds:DescribeDBInstances\u0026#34;, \u0026#34;rds:DescribeDBSubnetGroups\u0026#34;, \u0026#34;rds:ListTagsForResource\u0026#34;, \u0026#34;cloudwatch:GetMetricData\u0026#34;, \u0026#34;cloudwatch:ListMetrics\u0026#34;, \u0026#34;cloudwatch:GetMetricStatistics\u0026#34;, \u0026#34;logs:DescribeLogStreams\u0026#34;, \u0026#34;logs:GetLogEvents\u0026#34;, \u0026#34;logs:FilterLogEvents\u0026#34;, \u0026#34;ec2:DescribeSecurityGroups\u0026#34;, \u0026#34;ec2:DescribeSubnets\u0026#34;, \u0026#34;ec2:DescribeVpcs\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Only grant Describe permissions to RDS and EC2. No write access is needed to follow the principle of least privilege.\nClick Next Name and create the policy Enter name: CustomDocumentDBAccess Click Create policy Verify result The system will display a success message Create Role Initialize IAM Role In the IAM console, go to the Roles tab Click Create role Select Trusted entity type: AWS service Select Use case: EC2 Click Next Attach required policies to the role Search and select the following policies: AmazonSSMManagedInstanceCore CloudWatchAgentServerPolicy AmazonS3FullAccess CustomDocumentDBAccess AmazonSESFullAccess If you want to limit permissions for S3 or SES, you can create a custom policy instead of using FullAccess.\nClick Next Name and create the role Enter role name: EC2-Backend-FoodApp-Role Click Create role Verify result The system will display a success message This IAM Role will be attached to the backend EC2 instance in the next step to ensure secure communication with services like SES, S3, DocumentDB, and CloudWatch.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.6-launchtemplate/","title":"Create Launch Template","tags":[],"description":"","content":"Launch Template is a predefined EC2 configuration template that allows automatic and standardized instance creation. This is a required step before deploying the Auto Scaling Group, as ASG uses this template to automatically create new backend EC2 instances when scaling or replacing failed instances.\nIn the FoodApp system, the Launch Template will include:\nThe pre-created AMI ami-backend-foodapp Security Group SG-EC2 IAM Role EC2-Backend-FoodApp-Role A User data script to automatically start the backend using PM2 whenever a new instance is launched This ensures that every backend instance created will have a consistent configuration and will be ready to serve traffic immediately once registered with the ALB.\nCreate Launch Templates Initialize the Launch Template Go to the EC2 service, then select Launch Templates from the left menu. Click Create launch template Enter name and select AMI Template name: lt-backend-foodapp Under Application and OS Images Select the My AMIs tab Choose the AMI: ami-backend-foodapp (created earlier) Configure instance type In the Instance type section, select t2.micro Set SSH key and security SSH Key Pair: orderingfoodkey Under Firewall (security groups), select SG-EC2 Attach IAM Role Under Advanced details, assign IAM Role EC2-Backend-FoodApp-Role to the instance Add User Data to automatically start backend In the User data section, insert the startup script to automatically launch the Node.js backend using PM2 This ensures the backend server runs immediately once the EC2 is launched via Auto Scaling #!/bin/bash cd /home/ssm-user/foodapp-backend npm install -g pm2 npm install pm2 start server.js pm2 save pm2 startup Finalize template creation Review all settings on the right in the Summary section Click Create launch template Verify the result "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/","title":"Deploying Backend","tags":[],"description":"","content":"This chapter guides you through deploying the FoodApp backend on Amazon EC2 following a High Availability architecture. The backend will be deployed step-by-step to ensure:\nAutomatic scaling when traffic increases (Auto Scaling) High availability through Load Balancer and Health Checks Monitoring and recovery capability in case of failure The steps in this chapter include:\nInstalling the backend with PM2 Creating Target Group \u0026amp; Application Load Balancer (ALB) for distributing requests Creating AMI \u0026amp; Launch Template to easily spin up new backend EC2 instances Creating an Auto Scaling Group (ASG) to maintain appropriate number of backend instances After completing this chapter, you will have a Node.js backend system on AWS that is scalable and highly resilient.\nConfigure connection with AWS Services Set up PM2 Create Target Group Create Application Load Balancer Create AMI Create Launch Template Create Auto Scaling Group "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/2-preparation/2.6-ec2instance/","title":"Tạo EC2 instance","tags":[],"description":"","content":"The EC2 instance will serve as the backend server for the FoodApp system. It will handle requests from the frontend, interact with DocumentDB, send emails via Amazon SES, and store images in Amazon S3.\nIn this section, we will create an EC2 instance with the following characteristics:\nUse Ubuntu 22.04 LTS for easy Node.js environment setup Place it in a Private Subnet to enhance security (only accessible via ALB) Attach IAM Role (EC2-Backend-FoodApp-Role) to allow EC2 to interact with AWS services like SES, S3, and DocumentDB Attach Security Group SG-EC2, which only allows traffic from ALB to port 5000 After creation, this EC2 instance will be used to deploy the FoodApp Node.js backend source code.\nCreate EC2 Instance Initialize EC2 Instance Go to the EC2 Dashboard Select the Instances tab Click Launch instances Configure the instance Name: ec2-backend-foodapp Application and OS images: Choose: Quick Start OS: Ubuntu AMI: Ubuntu Server 22.04 LTS Instance type: t2.micro Key pair: select orderingfoodkey Network settings: VPC: select vpc-foodapp Subnet: subnet-private-1 Firewall: Select existing security group Common security groups: select SG-EC2 Advanced details: IAM instance profile: select EC2-Backend-FoodApp-Role Click Launch instance to complete The IAM Role allows the backend EC2 instance to send logs, query DocumentDB, send emails via SES, and upload images to S3 without using access keys.\nVerify result The system will display a success confirmation message "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/6-backend/6.7-autoscalinggroup/","title":"Create Auto Scaling Group","tags":[],"description":"","content":"Auto Scaling Group (ASG) is the component that enables the backend system to automatically scale based on demand and self-heal in case of failures. When combined with Launch Template and Application Load Balancer (ALB), ASG ensures that the system always maintains a sufficient number of active backend EC2 instances, ready to handle incoming traffic.\nIn the FoodApp system, the Auto Scaling Group helps:\nAutomatically create new EC2 instances from Launch Template lt-backend-foodapp when needed Place EC2s into two Private Subnets to improve availability (multi-AZ) Automatically register EC2s to the ALB Target Group tg-backend Continuously monitor instance health via ALB Health Check This is the final step in building a Highly Available Web Application architecture, ensuring the backend is scalable, fault-tolerant, and operates 24/7.\nCreate Auto Scaling Groups Initialize Auto Scaling Group Go to the AWS EC2 Console Select the Auto Scaling groups tab Click Create Auto Scaling group Basic configuration Name: asg-backend-foodapp Launch template: lt-backend-foodapp Select the latest version Click Next Network configuration VPC: vpc-foodapp Availability zones \u0026amp; subnets: subnet-private-1 subnet-private-2 Click Next Attach Load Balancer Load balancing: Attach to an existing load balancer Existing target group: tg-backend Enable: Turn on Elastic Load Balancing health checks Click Skip to review Create Auto Scaling Group Click Create Auto Scaling group Verify the result Go to the Instances tab, you’ll see a new EC2 instance automatically launched by the Auto Scaling Group (ASG) using the Launch Template. Navigate to Target Group, select the Targets tab to check the Health Check status. Ensure that the instance shows as healthy to confirm the backend is functioning properly. It may take 1–2 minutes for the instance state to change from initial to healthy. Please be patient.\n"},{"uri":"https://npmh1909.github.io/foodapp-high-availability/7-frontend/","title":"Deploying Frontend and Configuring CloudFront Logging","tags":[],"description":"","content":"After the backend has been fully deployed with auto-scaling and monitoring capabilities, the next step is to deploy the frontend interface so users can interact with the system.\nIn this chapter, we will perform a complete frontend deployment including:\nDeploying the frontend source code to Amazon S3 using Static Website Hosting Creating a CloudFront Distribution to accelerate and secure access Enabling CloudFront Logging to monitor access activity in real-time and periodically After completing this chapter, you will have a publicly deployed frontend that is performance-optimized, fully monitored, and seamlessly integrated with the backend system via Load Balancer.\nDeploy frontend to Amazon S3 Create CloudFront Distribution Enable CloudFront Logging "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/8-cleanup/","title":"Resource Cleanup","tags":[],"description":"","content":"We will go through the following steps to delete all resources created during this hands-on lab.\nDelete Distribution Select the distribution Click Disable Confirm Disable Click Delete Confirm Delete Delete Data Stream Select the data stream Click Actions Choose Delete Type delete Confirm Delete Delete S3 Bucket Select the bucket Click Empty Type permanently delete Confirm Empty Click Delete Enter the bucket name Confirm Delete bucket Delete Auto Scaling Group Select the Auto Scaling Group Click Actions Choose Delete Type delete Confirm Delete Delete Launch Template Select the Launch Template Click Actions Choose Delete template Type delete Confirm Delete Delete Amazon Machine Image (AMI) Select the AMI Click Actions Choose Deregister AMI Confirm Deregister AMI Delete Elastic Load Balancer Select the load balancer Click Actions Choose Delete load balancer Type confirm Confirm Delete Delete Target Group Select the target group Click Actions Choose Delete Confirm Delete Delete DocumentDB Cluster Select the cluster Click Actions Choose Delete Select No Check I acknowledge that upon cluster deletion Enter delete entire cluster Confirm Delete Delete Subnet Group Select the subnet group Click Actions Choose Delete Confirm Delete Terminate EC2 Instance Select the instance Click Instance state Choose Terminate instance Confirm Terminate Delete NAT Gateway Select the NAT gateway Click Instance state Choose Terminate instance Confirm Terminate Delete Route Table Select the route table Click Actions Choose Edit subnet associations Uncheck all subnets Click Save associations Click Actions Choose Delete route table Enter delete Confirm Delete Delete Internet Gateway Select the internet gateway Click Actions Choose Detach from VPC Confirm Detach internet gateway Click Actions Choose Delete internet gateway Enter delete Confirm Delete internet gateway Release Elastic IP Address Select the Elastic IP Click Actions Choose Release Elastic IP addresses Confirm Release Delete Subnet Select the subnet Click Actions Choose Delete subnet Enter delete Confirm Delete Delete VPC Select the VPC Click Actions Choose Delete VPC Enter delete Confirm Delete "},{"uri":"https://npmh1909.github.io/foodapp-high-availability/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://npmh1909.github.io/foodapp-high-availability/tags/","title":"Tags","tags":[],"description":"","content":""}]